///<reference path="../../../typings/includes.d.ts"/>

import pg = require('pg');

/**
 *
 */
module DBReq {

    function predicate(line : any) {

        return function(elt : any) {

            return (
                (elt.recommendationStyle !== null && (elt.recommendationStyle.trim() === line.recommendationStyle.trim())) ||
                    line.sceneId === elt.sceneId
            );

        }

    }

// var pg = require('pg');
var pgc = require('../../private.js');
var Log = require('../../lib/log.js');
var async = require('async');

}

/**
 * Class that checks if an user id exists
 * @param id {Number} id of the user to check
 * @param finishAction {function} callback that has as a parameter which is a
 * boolean indicating wether the user id exists or not
 * @memberof DBReq
 * @constructor
 * @private
 */
DBReq.UserIdChecker = function(id, finishAction) {
    this.id = id;
    this.finishAction = finishAction;

    var self = this;
    pg.connect(pgc.url, function(err, client, release) {
        self.client = client;
        self.release = release;
        self.execute();
    });
}

/**
 * Executes the SQL request and calls the callback
 */
DBReq.UserIdChecker.prototype.execute = function() {
    var self = this;
    this.client.query(
        "SELECT count(id) > 0 AS answer FROM users WHERE id = $1;",
        [self.id],
        function(err, result) {
            if (err !== null) {
                Log.dberror(err + ' in UserIdChecker');
                return;
            }
            self.finalResult = result.rows[0].answer;
            self.finish();
        }
    );
}

/**
 * Release the DB connection and call the callback
 */
DBReq.UserIdChecker.prototype.finish = function() {
    this.release();
    this.client = null;
    this.release = null;

    this.finishAction(this.finalResult);
}

/**
 * Class that checks if a workerId exists
 * @param id {string} workerId of to test
 * @param finishAction {function} callback that has as a parameter which is a
 * boolean indicating wether the user id exists or not
 * @memberof DBReq
 * @constructor
 * @private
 */
DBReq.UserNameChecker = function(name, finishAction) {
    this.name = name;
    this.finishAction = finishAction;
    var self = this;
    pg.connect(pgc.url, function(err, client, release) {
        if (err) {
            Log.dberror(err + ' in UserNameChcker connection');
            return;
        }
        self.client = client;
        self.release = release;
        self.execute();
    });
}

/**
 * Executes the SQL request and calls the callback
 */
DBReq.UserNameChecker.prototype.execute = function() {
    var self = this;
    this.client.query(
        "SELECT count(id) > 0 AS answer FROM users WHERE worker_id = $1",
        [self.name],
        function(err, result) {
            if (err !== null) {
                Log.dberror(err + ' in UserNameChecker');
                return;
            }
            self.finalResult = result.rows[0].answer;
            self.finish();
        }
    );

}

/**
 * Release the DB connection and call the callback
 */
DBReq.UserNameChecker.prototype.finish = function() {
    this.release();
    this.client = null;
    this.release = null;

    this.finishAction(this.finalResult);
}

/**
 * Class that checks if an experiment exists
 * @param id {Number} id of the experiment to check
 * @param finishAction {function} callback that has as a parameter which is the
 * id of the scene if the experiment exists, or null otherwise
 * @memberof DBReq
 * @constructor
 * @private
 */
DBReq.ExpIdChecker = function(id, finishAction) {
    this.id = id;
    this.finishAction = finishAction;

    var self = this;
    pg.connect(pgc.url, function(err, client, release) {
        self.client = client;
        self.release = release;
        self.execute();
    });
}

/**
 * Executes the SQL request and calls the callback
 */
DBReq.ExpIdChecker.prototype.execute = function() {
    var self = this;
    this.client.query(
        "SELECT scene_id AS \"sceneId\" FROM experiment, CoinCombination WHERE CoinCombination.id = Experiment.coin_combination_id AND Experiment.id = $1;",
        [self.id],
        function(err, result) {
            if (result === undefined || result.rows.length === 0) {
                self.finalResult = null;
            } else {
                self.finalResult = result.rows[0].sceneId;
            }
            self.finish();
        }
    );
}

/**
 * Release the DB connection and call the callback
 */
DBReq.ExpIdChecker.prototype.finish = function() {
    this.release();
    this.client = null;
    this.release = null;

    this.finishAction(this.finalResult);
}

/**
 * Class that gives access to the last not finished experiment
 * @param id {Number} id of the user of who you want the last experiment
 * @param finishAction {function} callback that has as parameters
 * <ol>
 *  <li>the id of the experiment (Number)</li>
 *  <li>the id of the coin combination (Number)</li>
 *  <li>the id of the scene (Number)</li>
 *  <li>the recommendation style (string)</li>
 *  <li>the coins (Number[])</li>
 * </ol>xperiment exists, or null otherwise
 * @memberof DBReq
 * @private
 * @constructor
 */
DBReq.LastExpGetter = function(userId, finishAction) {

    var self = this;
    this.userId = userId;
    this.finishAction = finishAction;
    this.finalResult = {}

    if (this.userId === undefined) {
        return;
    }

    pg.connect(pgc.url, function(err, client, release) {
        self.client = client;
        self.release = release;
        self.execute();
    });
}

/**
 * Executes the SQL request and calls the callback
 */
DBReq.LastExpGetter.prototype.execute = function() {
    var self = this;
    this.client.query(
        'SELECT scene_id AS "sceneId", \n' +
        '       coin_1, \n' +
        '       coin_2, \n' +
        '       coin_3, \n' +
        '       coin_4, \n' +
        '       coin_5, \n' +
        '       coin_6, \n' +
        '       coin_7, \n' +
        '       coin_8, \n' +
        '       Experiment.recommendation_style AS "recommendationStyle", \n' +
        '       Experiment.id AS "expId", \n' +
        '       CoinCombination.id as "coinCombinationId" \n' +
        'FROM Experiment, CoinCombination \n' +
        'WHERE Experiment.coin_combination_id = CoinCombination.id \n' +
        '      AND Experiment.user_id = $1 \n' +
        '      AND NOT Experiment.finished \n' +
        'ORDER BY Experiment.id DESC \n' +
        'LIMIT 1;',
        [self.userId],
        function (err, result) {

            if (err !== null) {
                Log.dberror(err + ' in LastExpGetter (DBReq)');
            }

            if (result.rows.length === 0) {
                Log.debug('Timeout', true);
                setTimeout(function() {
                    self.execute();
                }, 1000);
                return;
            }

            self.client.query(
                'UPDATE Experiment SET finished = true WHERE id = $1',
                [result.rows[0].expId],
                function() {
                    self.finalResult.sceneId = result.rows[0].sceneId;
                    self.finalResult.recommendationStyle = result.rows[0].recommendationStyle;
                    self.finalResult.coins = [
                        result.rows[0].coin_1,
                        result.rows[0].coin_2,
                        result.rows[0].coin_3,
                        result.rows[0].coin_4,
                        result.rows[0].coin_5,
                        result.rows[0].coin_6,
                        result.rows[0].coin_7,
                        result.rows[0].coin_8
                    ];
                    self.finalResult.coinCombinationId = result.rows[0].coinCombinationId;
                    self.finalResult.expId = result.rows[0].expId;
                    self.finish();

                }
            );
        }
    );
}

/**
 * Release the DB connection and call the callback
 */
DBReq.LastExpGetter.prototype.finish = function() {
    this.release();
    this.client = null;
    this.release = null;

    this.finishAction(
        this.finalResult.expId,
        this.finalResult.sceneId,
        this.finalResult.coinCombinationId,
        this.finalResult.recommendationStyle,
        this.finalResult.coins
    );
}

/**
 * Class that gets the info from all experiment
 * @param finishAction {function} callback that has as a parameter which is an
 * array of objects containing the id, the username, the name of the scene and
 * the id of the user.
 * @memberof DBReq
 * @constructor
 * @private
 */
DBReq.ExpGetter = function(finishAction) {
    this.finishAction = finishAction;

    var self = this;
    pg.connect(pgc.url, function(err, client, release) {
        self.client = client;
        self.release = release;
        self.execute();
    });
}

/**
 * Executes the SQL request and calls the callback
 */
DBReq.ExpGetter.prototype.execute = function() {
    var self = this;
    this.client.query(
        "SELECT  " +
            "experiment.id AS \"expId\", " +
            "users.worker_id AS username, " +
            "scene.name AS scenename, " +
            "users.id AS \"userId\" " +
        "FROM experiment, users, scene, CoinCombination " +
        "WHERE experiment.user_id = users.id and scene.id = CoinCombination.scene_id AND " +
        "      Experiment.coin_combination_id = CoinCombination.id " +
        "ORDER BY experiment.id;",
        [],
        function(err, result) {
            self.finalResult = result.rows;
            self.finish();
        }
    );
}

/**
 * Release the DB connection and call the callback
 */
DBReq.ExpGetter.prototype.finish = function() {
    this.release();
    this.client = null;
    this.release = null;

    this.finishAction(this.finalResult);
}

/**
 * Class that creates a tutorial
 * @param id {Number} id of the user doing the tutorial
 * @param finishAction {function} callback that has as parameters
 * <ol>
 *  <li>the id of the experiment (Number)</li>
 *  <li>the id of the generated coins (Number[])</li>
 * </ol>
 * @memberof DBReq
 * @constructor
 * @private
 */
DBReq.TutorialCreator = function(id, finishAction) {
    this.id = id;
    this.finishAction = finishAction;
    this.finalResult = {}

    var self = this;
    pg.connect(pgc.url, function(err, client, release) {
        self.client = client;
        self.release = release;
        self.execute();
    });
}

/**
 * Executes the SQL request and calls the callback
 */
DBReq.TutorialCreator.prototype.execute = function() {
    var self = this;
    this.client.query(
        // Generate random coins
        "SELECT Scene.id AS \"sceneId\", generate_series AS id\n" +
        "FROM Scene, generate_series(0,Scene.coin_number-1)\n" +
        "WHERE Scene.name = 'peachcastle'\n" +
        "ORDER BY RANDOM()\n" +
        "LIMIT 8;",
        [],
        function(err, result) {
            self.finalResult.coins = [];
            for (var i = 0; i < 8; i++) {
                self.finalResult.coins.push(result.rows[i].id);
            }
            // Create CoinCombination
            self.client.query(
                "INSERT INTO CoinCombination(scene_id, coin_1, coin_2, coin_3, coin_4, coin_5, coin_6, coin_7, coin_8)\n" +
                "VALUES($1,$2,$3,$4,$5,$6,$7,$8,$9)\n" +
                "RETURNING id;",
                [
                    result.rows[0].sceneId,
                    result.rows[0].id,
                    result.rows[1].id,
                    result.rows[2].id,
                    result.rows[3].id,
                    result.rows[4].id,
                    result.rows[5].id,
                    result.rows[6].id,
                    result.rows[7].id
                ],
                function(err, result) {
                    // Create experiment
                    self.client.query(
                        "INSERT INTO Experiment(user_id, coin_combination_id, finished)\n" +
                        "VALUES($1,$2, true)\n" +
                        "RETURNING id;",
                        [self.id, result.rows[0].id],
                        function(err, result) {
                            self.finalResult.expId = result.rows[0].id;
                            self.finish();
                        }
                    );
                }
            );
        }
    );
}

/**
 * Release the DB connection and call the callback
 */
DBReq.TutorialCreator.prototype.finish = function() {
    this.release();
    this.release = null;
    this.client = null;

    this.finishAction(this.finalResult.expId, this.finalResult.coins);
}

/**
 * Class that verifies that a user has correctly done all the experiments
 * @param userId {Number} id of the user to verify
 * @param finishAction {function} callback that has as parameter a boolean
 * which is true is the verification was a success
 * @memberof DBReq
 * @constructor
 * @private
 */
DBReq.UserVerifier = function(userId, finishAction) {
    this.userId = userId;
    this.finishAction = finishAction;
    var self = this;

    pg.connect(pgc.url, function(err, client, release) {
        self.client = client;
        self.release = release;

        self.execute();
    });
}

/**
 * Executes the SQL request and calls the callback
 */
DBReq.UserVerifier.prototype.execute = function() {

    var self = this;
    this.client.query(
        "SELECT id as \"expId\" FROM Experiment WHERE user_id = $1",
        [self.userId],
        function(err, result) {
            if (result.rows.length !== 4) {
                self.finish(false);
            }

            async.map(
                result.rows,
                function(elt, callback) {
                    self.client.query(
                        "SELECT count(*) > 5 AS ok FROM CoinClicked WHERE exp_id = $1",
                        [elt.expId],
                        function(err, result) {
                            callback(null, result.rows[0].ok === true);
                        }
                    );
                },
                function(err, result) {
                    var ok = result.reduce(function(prev, next) { return prev && next; });
                    self.client.query(
                        "UPDATE Users SET valid = $1 WHERE id = $2",
                        [ok, self.userId],
                        function(err, result) {
                            self.finish(ok);
                        }
                    );
                }
            );
        }
    );

}

/**
 * Release the DB connection and call the callback
 */
DBReq.UserVerifier.prototype.finish = function(finalResult) {
    this.release();

    this.client = null;
    this.release = null;
    this.finishAction(finalResult);
}

/**
 * Class that gets the "valid" attribute of a user in the databse
 * @param userId {Number} id of the user
 * @param finishAction {function} callback that has as parameters :
 * <ol>
 *  <li>the workerId of the user (string)</li>
 *  <li>the "valid" attribute of the database (boolean)</li>
 * </ol>
 * @memberof DBReq
 * @constructor
 * @private
 */
DBReq.UserGetter = function(userId, finishAction) {
    this.userId = userId;
    this.finishAction = finishAction;

    var self = this;
    pg.connect(pgc.url, function(err, client, release) {
        self.client = client;
        self.release = release;

        self.execute();
    });
}

/**
 * Executes the SQL request and calls the callback
 */
DBReq.UserGetter.prototype.execute = function() {
    var self = this;

    this.client.query(
        'SELECT worker_id AS "workerId", valid FROM Users WHERE id = $1',
        [self.userId],
        function(err, result) {
            self.finish(result.rows[0].workerId, result.rows[0].valid);
        }
    );
}

/**
 * Release the DB connection and call the callback
 */
DBReq.UserGetter.prototype.finish = function(workerId, valid) {

    this.release();
    this.release = null;
    this.client = null;

    this.finishAction(workerId, valid);

}

/**
 * Try to get a user by id, and creates it if it doesn't exists
 * @param id {Number} id to test
 * @param callback {function} callback to call on the id
 * @memberof DBReq
 */
DBReq.tryUser = function(id, callback) {
    if (id !== undefined && id !== null) {
        new DBReq.UserIdChecker(id, function(clear) {
            if (clear) {
                callback(id);
            } else {
                new DBReq.UserCreator(callback);
            }
        });
    } else {
        new DBReq.UserCreator(callback);
    }
}

// Helper for the rest
// http://stackoverflow.com/questions/9830359/apply-an-array-to-a-constructor-function-in-javascript
function construct(constr, args) {
  var instance = Object.create(constr.prototype);
  var result = constr.apply(instance, args);
  return typeof result === 'object' ? result : instance;  // yes, this is what 'new' does
}

/**
 * Loads every information from an experiment
 * (wraps the {@link DBReq.Info} constructor)
 * @param id {Number} id of the experiment to load
 * @param finishAction {function} callback on the result when loading is
 * finished
 * @memberof DBReq
 */
DBReq.getInfo = function() { construct(DBReq.Info, arguments); }

/**
 * Creates an user
 * (wraps the {@link DBReq.UserCreator} constructor)
 * @param workerId {string} the name of the person doing the experiment
 * @param age {string} a string representing an age range
 * @param male {boolean} indicates if the user is a man or a woman
 * @param rating {Number} between 1 and 5, describes the level of the user
 * @param lastTime {Number} between 0 and 3 such that
 * <ol start="0">
 *  <li>never played</li>
 *  <li>this year</li>
 *  <li>this month</li>
 *  <li>this week</li>
 * </ol>
 * @param finishAction {function} callback that has as a parameter the id of
 * the new user
 * @memberof DBReq
 */
DBReq.createUser = function() { construct(DBReq.UserCreator, arguments); }

/**
 * Creates an experiment
 * (wraps the {@link DBReq.ExpCreator} constructor)
 * @param userId {Number} id of the user that does the experiment
 * @param experiments {Object[]} array of objects representing the experiments
 * that the user has already done <code>{sceneId: Number, recommendationStyle: string, coins Number[]}</code>
 * @param finishAction {function} callback that has as parameters
 * <ol>
 *  <li>the id of the experiment (Number)</li>
 *  <li>the id of the coin combination (Number)</li>
 *  <li>the id of the scene (Number)</li>
 *  <li>the recommendation style (string)</li>
 *  <li>the coins (Number[])</li>
 * </ol>
 * @memberof DBReq
 */
DBReq.createExp = function() { construct(DBReq.ExpCreator, arguments); }

/**
 * Creates a tutorial
 * (wraps the {@link DBReq.TurorialCreator} constructor)
 * @param id {Number} id of the user doing the tutorial
 * @param finishAction {function} callback that has as parameters
 * <ol>
 *  <li>the id of the experiment (Number)</li>
 *  <li>the id of the generated coins (Number[])</li>
 * </ol>
 * @memberof DBReq
 */
DBReq.createTutorial = function() { construct(DBReq.TutorialCreator, arguments); }

/**
 * Checks if an user id exists
 * (wraps the {@link DBReq.UserIdChecker} constructor)
 * @param id {Number} id of the user to check
 * @param finishAction {function} callback that has as a parameter which is a
 * boolean indicating wether the user id exists or not
 * @memberof DBReq
 */
DBReq.checkUserId = function() { construct(DBReq.UserIdChecker, arguments); }

/**
 * Checks if a workerId exists
 * (wraps the {@link DBReq.UserNameChecker} constructor)
 * @param id {string} workerId of to test
 * @param finishAction {function} callback that has as a parameter which is a
 * boolean indicating wether the user id exists or not
 * @memberof DBReq
 */
DBReq.checkUserName = function() { construct(DBReq.UserNameChecker, arguments); }

/**
 * Checks if an experiment exists
 * (wraps the {@link DBReq.ExpIdChecker} constructor)
 * @param id {Number} id of the experiment to check
 * @param finishAction {function} callback that has as a parameter which is the
 * id of the scene if the experiment exists, or null otherwise
 * @memberof DBReq
 */
DBReq.checkExpId = function() { construct(DBReq.ExpIdChecker, arguments); }

/**
 * Gets the info from all experiment
 * (wraps the {@link DBReq.ExpGetter} constructor)
 * @param finishAction {function} callback that has as a parameter which is an
 * array of objects containing the id, the username, the name of the scene and
 * the id of the user.
 * @memberof DBReq
 */
DBReq.getAllExps = function() { construct(DBReq.ExpGetter, arguments); }

/**
 * Gives access to the last not finished experiment
 * (wraps the {@link DBReq.LastExpGetter} constructor)
 * @param id {Number} id of the user of who you want the last experiment
 * @param finishAction {function} callback that has as parameters
 * <ol>
 *  <li>the id of the experiment (Number)</li>
 *  <li>the id of the coin combination (Number)</li>
 *  <li>the id of the scene (Number)</li>
 *  <li>the recommendation style (string)</li>
 *  <li>the coins (Number[])</li>
 * </ol>xperiment exists, or null otherwise
 * @memberof DBReq
 */
DBReq.getLastExp = function() { construct(DBReq.LastExpGetter, arguments); }

/**
 * Verifies that a user has correctly done all the experiments
 * (wraps the {@link DBReq.UserVerifier} constructor)
 * @param userId {Number} id of the user to verify
 * @param finishAction {function} callback that has as parameter a boolean
 * which is true is the verification was a success
 * @memberof DBReq
 */
DBReq.verifyUser = function() { construct(DBReq.UserVerifier, arguments); }

/**
 * Gets the "valid" attribute of a user in the databse
 * (wraps the {@link DBReq.UserGetter} constructor)
 * @param userId {Number} id of the user
 * @param finishAction {function} callback that has as parameters :
 * <ol>
 *  <li>the workerId of the user (string)</li>
 *  <li>the "valid" attribute of the database (boolean)</li>
 * </ol>
 * @memberof DBReq
 */
DBReq.getUser = function() { construct(DBReq.UserGetter, arguments); }

module.exports = DBReq;

}
